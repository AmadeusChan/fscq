- double-indirect blocks
- byte-level read/write
- factor out on-disk list code from MemLog
- bigger log (more than one descriptor block)
- deleting a file should free its data blocks
- TRIM support (TRIM opcode randomizes block contents)
- prove end-to-end theorem about mkfs
- non-journaled data writes (file fsync)
- asynchronous metadata updates (directory fsync)
- implement ext3/4 logging optimizations
  delay applying log to disk
  batch transactions 
  checksum of log in header

- extraction without Haskell
- integrate into MirageOS unikernel by extracting to OCaml
- extraction into Go to combine with Biscuit
- explore Mtac as an alternative to Ltac

- better syntax for predicates (from paper)
- better automation support for words
- better automation support for stopping at well-defined points
- use http://why.lri.fr/ or http://why3.lri.fr/ to integrate Z3 into Coq
- use Canonical Structure for defaults
- integrate error codes (Errno.v)
- k/v store, on-disk hash table (stephanie)
- db transaction system (abort)
- combine Verdi's Paxos with FSCQ for stable storage, prove end-to-end theorem
  under both network and node failures (how to combine different spec styles??)
- add security to fscq specs (something better than ACLs; maybe capsicum?)
- provably secure sandbox on top of fscq
- concurrent transactions

===

//- do we need to change our valuset handling to always use subsets rather than exact equality?
//  this would enable us to get rid of the per-address Sync, and instead switch to a global
//  Sync opcode in the lowest level.
//- writeback cache (integrate ReadCache and WritebackCache)
- eviction from GroupLog
- prove AtomicCp
- prove mkfs

- clean up DirTree (no lists, update_subtree_helper, etc)
- bring back ByteFile
- high-performance extraction
- simplify AtomicCp proofs
  apply pred to diskset
- more applications
- security specs: need to deal with non-determinism, and at the lowest level,
  need to change the semantics to show that the disk independently chooses
  which valu to preserve from a valuset (i.e., non-interference between sector
  crashes)

